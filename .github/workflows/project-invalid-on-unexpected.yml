# .github/workflows/project-invalid-on-unexpected.yml
name: "Project: mark Invalid when commits reference Backlog issues"
on:
  push:
    branches: ["**"]
  workflow_dispatch: {}

env:
  PROJECT_URL: https://github.com/orgs/Tiny-Clowns/projects/6/views/1

jobs:
  mark_invalid:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: read
      checks: read
      repository-projects: write
    steps:
      - name: Resolve Project v2
        id: proj
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const m = (process.env.PROJECT_URL||"").match(/\/orgs\/([^/]+)\/projects\/(\d+)/i);
            if (!m) return core.setFailed("Bad PROJECT_URL");
            const owner = m[1], number = parseInt(m[2],10);
            const r = await github.graphql(`query($o:String!,$n:Int!){
              organization(login:$o){
                projectV2(number:$n){
                  id
                  fields(first:50){ nodes{ ... on ProjectV2SingleSelectField { id name options{ id name } } } }
                }
              }}`, { o: owner, n: number });
            const p = r.organization?.projectV2; if (!p) return core.setFailed("Project not found");
            const status = (p.fields.nodes||[]).find(f=>f?.name==="Status");
            const invalid = status?.options.find(o=>/invalid/i.test(o.name));
            core.setOutput("projectId", p.id);
            core.setOutput("statusFieldId", status?.id||"");
            core.setOutput("invalidId", invalid?.id||"");

      - name: Mark Backlog references → Invalid
        if: ${{ steps.proj.outputs.projectId != '' && steps.proj.outputs.statusFieldId != '' && steps.proj.outputs.invalidId != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const projectId = "${{ steps.proj.outputs.projectId }}";
            const fieldId   = "${{ steps.proj.outputs.statusFieldId }}";
            const invalidId = "${{ steps.proj.outputs.invalidId }}";

            const nums = new Set();
            for (const c of (context.payload.commits || [])) {
              const msg = c.message || "";
              for (const m of msg.matchAll(/#(\d{1,7})/g)) nums.add(parseInt(m[1],10));
            }
            if (!nums.size) { core.info("No issue refs in commits"); return; }

            async function issueId(num){
              const r = await github.graphql(`query($o:String!,$r:String!,$n:Int!){
                repository(owner:$o,name:$r){ issue(number:$n){ id } }
              }`, { o: owner, r: repo, n: num }).catch(()=>null);
              return r?.repository?.issue?.id || null;
            }
            async function addItem(contentId){
              const a = await github.graphql(`mutation($p:ID!,$c:ID!){
                addProjectV2ItemById(input:{projectId:$p,contentId:$c}){ item{ id } }
              }`, { p: projectId, c: contentId }).catch(()=>null);
              return a?.addProjectV2ItemById?.item?.id || null;
            }
            async function statusName(itemId){
              const q = await github.graphql(`query($id:ID!){
                node(id:$id){
                  ... on ProjectV2Item {
                    fieldValues(first:50){ nodes{
                      ... on ProjectV2ItemFieldSingleSelectValue { name field{ ... on ProjectV2SingleSelectField { name id } } }
                    }}
                  }
                }
              }`, { id: itemId });
              const v = q?.node?.fieldValues?.nodes || [];
              return v.find(x => x.field?.name === "Status")?.name || null;
            }
            async function setInvalid(itemId){
              await github.graphql(`mutation($p:ID!,$i:ID!,$f:ID!,$o:String!){
                updateProjectV2ItemFieldValue(input:{projectId:$p,itemId:$i,fieldId:$f,value:{singleSelectOptionId:$o}}){ clientMutationId }
              }`, { p: projectId, i: itemId, f: fieldId, o: invalidId });
            }

            for (const n of nums) {
              const id = await issueId(n); if (!id) continue;
              const itemId = await addItem(id); if (!itemId) continue;
              const cur = await statusName(itemId); if (!cur) continue;
              if (/^backlog$/i.test(cur)) {
                await setInvalid(itemId);
                core.info(`#${n} → Invalid`);
              } else {
                core.info(`#${n} is '${cur}', skip`);
              }
            }
