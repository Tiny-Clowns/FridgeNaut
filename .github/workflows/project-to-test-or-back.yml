# .github/workflows/project-to-test-or-back.yml
name: "Project: To Test when all checks succeed, back to In Progress on failure (develop)"
on:
  workflow_run:
    workflows: ["ci", "codeql"] # exact names
    types: [completed]
  workflow_dispatch: {}

env:
  PROJECT_OWNER: "Mic12321"
  PROJECT_NUMBER: "3"

jobs:
  move_after_checks:
    if: ${{ github.event.workflow_run.head_branch == 'develop' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: read
      checks: read
      repository-projects: write
    steps:
      - name: Assert PROJECTS_TOKEN is configured
        run: |
          if [ -z "${{ secrets.PROJECTS_TOKEN }}" ]; then
            echo "Missing secret PROJECTS_TOKEN. Use a fine-grained PAT owned by Mic12321 with Projects Read/Write and repo read scopes." >&2
            exit 1
          fi
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}
          script: |
            const owner = process.env.PROJECT_OWNER;
            const repo  = context.repo.repo;
            const number = parseInt(process.env.PROJECT_NUMBER, 10);

            async function getProject(owner, number){
              const q = await github.graphql(`
                query($owner:String!,$number:Int!){
                  user(login:$owner){ p:projectV2(number:$number){ id fields(first:50){ nodes{ ... on ProjectV2SingleSelectField { id name options{ id name }}}}}}
                  organization(login:$owner){ p:projectV2(number:$number){ id fields(first:50){ nodes{ ... on ProjectV2SingleSelectField { id name options{ id name }}}}}}
                }`, { owner, number });
              return q.user?.p ?? q.organization?.p ?? null;
            }

            const sha = (context.payload.workflow_run && context.payload.workflow_run.head_sha) || process.env.GITHUB_SHA;
            const checks = await github.paginate(github.rest.checks.listForRef, { owner, repo, ref: sha, filter: "all", per_page: 100 });
            const runs = checks.flatMap(p => p.check_runs ?? []);
            if (!runs.length) { core.info("No check runs for commit"); return; }

            const incomplete = runs.filter(r => r.status !== "completed");
            if (incomplete.length) { core.info(`Checks still running (${incomplete.length}); skip`); return; }
            const failures = runs.filter(r => ["failure","timed_out","cancelled","action_required","stale"].includes((r.conclusion||"").toLowerCase()));
            const allSucceeded = failures.length === 0;

            const project = await getProject(owner, number);
            if (!project) return core.setFailed("Project not found");
            const statusField = project.fields.nodes.find(f => f?.name === "Status");
            if (!statusField) return core.setFailed("Status field not found");
            const toTest = statusField.options.find(o => /^to test$/i.test(o.name));
            const inProg = statusField.options.find(o => /in progress/i.test(o.name));
            if (allSucceeded && !toTest) return core.setFailed("'To Test' option missing");
            if (!allSucceeded && !inProg) return core.setFailed("'In Progress' option missing");

            const prs = (context.payload.workflow_run && context.payload.workflow_run.pull_requests) || [];
            if (!prs.length) { core.info("No PRs on this run"); return; }

            for (const pr of prs) {
              const prNumber = pr.number;
              const closingQ = await github.graphql(`
                query($owner:String!,$repo:String!,$pr:Int!){
                  repository(owner:$owner,name:$repo){
                    pullRequest(number:$pr){ closingIssuesReferences(first:50){ nodes{ id number } } }
                  }
                }`, { owner, repo, pr: prNumber });

              const issues = closingQ.repository.pullRequest.closingIssuesReferences.nodes;
              for (const iss of issues) {
                const add = await github.graphql(`
                  mutation($projectId:ID!,$contentId:ID!){
                    addProjectV2ItemById(input:{projectId:$projectId,contentId:$contentId}){ item{ id } }
                  }`, { projectId: project.id, contentId: iss.id }).catch(()=>null);
                const itemId = add?.addProjectV2ItemById?.item?.id; if (!itemId) continue;

                const optionId = allSucceeded ? toTest.id : inProg.id;
                await github.graphql(`
                  mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$optionId:String!){
                    updateProjectV2ItemFieldValue(input:{projectId:$projectId,itemId:$itemId,fieldId:$fieldId,value:{singleSelectOptionId:$optionId}}){ clientMutationId }
                  }`, { projectId: project.id, itemId, fieldId: statusField.id, optionId });
                core.info(`#${iss.number} â†’ ${allSucceeded ? "To Test" : "In Progress"}`);
              }
            }
