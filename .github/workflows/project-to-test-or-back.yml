# .github/workflows/project-to-test-or-back.yml
name: "Project: To Test when all checks succeed, back to In Progress on failure (develop)"
on:
  workflow_run:
    workflows: ["ci", "codeql"] # must match exact workflow names
    types: [completed]
  workflow_dispatch: {}

env:
  PROJECT_URL: https://github.com/orgs/Tiny-Clowns/projects/6/views/1

jobs:
  move_after_checks:
    if: ${{ github.event.workflow_run.head_branch == 'develop' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: read
      checks: read
      repository-projects: write
    steps:
      - name: App token
        id: app
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          owner: Tiny-Clowns

      - name: Resolve Project v2
        id: proj
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app.outputs.token }}
          script: |
            const m = (process.env.PROJECT_URL||"").match(/\/orgs\/([^/]+)\/projects\/(\d+)/i);
            if (!m) return core.setFailed("Bad PROJECT_URL");
            const owner = m[1], number = parseInt(m[2],10);
            const r = await github.graphql(`query($o:String!,$n:Int!){
              organization(login:$o){ projectV2(number:$n){
                id
                fields(first:50){ nodes{ ... on ProjectV2SingleSelectField { id name options{ id name } } } }
              }}}`, { o: owner, n: number });
            const p = r.organization?.projectV2; if (!p) return core.setFailed("Project not found");
            const status = (p.fields.nodes||[]).find(f=>f?.name==="Status");
            function opt(rx){ return status?.options.find(o=>rx.test(o.name))?.id || ""; }
            core.setOutput("projectId", p.id);
            core.setOutput("statusFieldId", status?.id||"");
            core.setOutput("toTestId", opt(/^to test$/i));
            core.setOutput("inProgId", opt(/in progress/i));

      - name: Move closing issues based on checks
        if: ${{ steps.proj.outputs.projectId != '' && steps.proj.outputs.statusFieldId != '' && (steps.proj.outputs.toTestId != '' || steps.proj.outputs.inProgId != '') }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app.outputs.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const projectId = "${{ steps.proj.outputs.projectId }}";
            const fieldId   = "${{ steps.proj.outputs.statusFieldId }}";
            const toTestId  = "${{ steps.proj.outputs.toTestId }}";
            const inProgId  = "${{ steps.proj.outputs.inProgId }}";

            const sha = (context.payload.workflow_run && context.payload.workflow_run.head_sha) || process.env.GITHUB_SHA;
            const checks = await github.paginate(github.rest.checks.listForRef, { owner, repo, ref: sha, filter: "all", per_page: 100 });
            const runs = checks.flatMap(p => p.check_runs ?? []);
            if (!runs.length) { core.info("No check runs for commit"); return; }
            const incomplete = runs.filter(r => r.status !== "completed");
            if (incomplete.length) { core.info(`Checks still running (${incomplete.length}); skip`); return; }
            const failures = runs.filter(r => ["failure","timed_out","cancelled","action_required","stale"].includes((r.conclusion||"").toLowerCase()));
            const allSucceeded = failures.length === 0;

            const prs = (context.payload.workflow_run && context.payload.workflow_run.pull_requests) || [];
            if (!prs.length) { core.info("No PRs on this run"); return; }

            const targetId = allSucceeded ? toTestId : inProgId;
            if (!targetId) { core.setFailed("Missing target Status option id"); return; }

            for (const pr of prs) {
              const prNumber = pr.number;
              const q = await github.graphql(`query($o:String!,$r:String!,$p:Int!){
                repository(owner:$o,name:$r){
                  pullRequest(number:$p){ closingIssuesReferences(first:50){ nodes{ id number } } }
                }
              }`, { o: owner, r: repo, p: prNumber });

              const issues = q.repository.pullRequest.closingIssuesReferences.nodes;
              for (const iss of issues) {
                const add = await github.graphql(`mutation($p:ID!,$c:ID!){
                  addProjectV2ItemById(input:{projectId:$p,contentId:$c}){ item{ id } }
                }`, { p: projectId, c: iss.id }).catch(()=>null);
                const itemId = add?.addProjectV2ItemById?.item?.id; if (!itemId) continue;

                await github.graphql(`mutation($p:ID!,$i:ID!,$f:ID!,$o:String!){
                  updateProjectV2ItemFieldValue(input:{projectId:$p,itemId:$i,fieldId:$f,value:{singleSelectOptionId:$o}}){ clientMutationId }
                }`, { p: projectId, i: itemId, f: fieldId, o: targetId });
                core.info(`#${iss.number} â†’ ${allSucceeded ? "To Test" : "In Progress"}`);
              }
            }
