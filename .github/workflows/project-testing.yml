name: "Issues: To Test → Testing when code reaches test"

on:
  pull_request:
    types: [closed]

  push:
    branches:
      - test

env:
  PROJECT_URL: https://github.com/orgs/Tiny-Clowns/projects/6/views/1

permissions:
  contents: read
  issues: read
  pull-requests: read
  repository-projects: write

jobs:
  update_issue_status:
    runs-on: ubuntu-latest

    steps:
      - name: App token
        id: app
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          owner: Tiny-Clowns

      - name: Resolve Project v2 Status field
        id: proj
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app.outputs.token }}
          script: |
            const m = (process.env.PROJECT_URL||"").match(/\/orgs\/([^/]+)\/projects\/(\d+)/i);
            if (!m) return core.setFailed("Bad PROJECT_URL");
            const owner = m[1], number = parseInt(m[2],10);

            const r = await github.graphql(`query($o:String!,$n:Int!){
              organization(login:$o){
                projectV2(number:$n){
                  id
                  fields(first:50){
                    nodes{
                      ... on ProjectV2SingleSelectField {
                        id
                        name
                        options{ id name }
                      }
                    }
                  }
                }
              }
            }`, { o: owner, n: number });

            const p = r.organization?.projectV2;
            if (!p) return core.setFailed("Project not found");

            const status = (p.fields.nodes||[]).find(f => f?.name === "Status");
            if (!status) return core.setFailed("Status field not found");

            function opt(name){
              return status.options.find(o => o.name === name)?.id || "";
            }

            core.setOutput("projectId", p.id);
            core.setOutput("statusFieldId", status.id);
            core.setOutput("toTestId",   opt("To Test"));
            core.setOutput("testingId",  opt("Testing"));
            core.setOutput("toFixId",    opt("To Fix"));
            core.setOutput("doneId",     opt("Done"));
            core.setOutput("invalidId",  opt("Invalid"));

      - name: Update project Status for referenced issues
        if: ${{ steps.proj.outputs.projectId != '' && steps.proj.outputs.statusFieldId != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app.outputs.token }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const eventName = context.eventName;

            const projectId     = "${{ steps.proj.outputs.projectId }}";
            const statusFieldId = "${{ steps.proj.outputs.statusFieldId }}";
            const toTestId      = "${{ steps.proj.outputs.toTestId }}";
            const testingId     = "${{ steps.proj.outputs.testingId }}";
            const toFixId       = "${{ steps.proj.outputs.toFixId }}";
            const doneId        = "${{ steps.proj.outputs.doneId }}";
            const invalidId     = "${{ steps.proj.outputs.invalidId }}";

            const issueRegex = /#(\d{1,7})/g;
            const issueNumbers = new Set();

            if (eventName === "pull_request") {
              const pr = context.payload.pull_request;

              // Only when merged into test
              if (!pr.merged || pr.base.ref !== "test") {
                core.info("PR not merged into test, skipping.");
                return;
              }

              const prText = `${pr.title}\n\n${pr.body || ""}`;
              let match;
              while ((match = issueRegex.exec(prText)) !== null) {
                issueNumbers.add(parseInt(match[1], 10));
              }

              const commits = await github.paginate(
                github.rest.pulls.listCommits,
                { owner, repo, pull_number: pr.number, per_page: 100 }
              );
              for (const c of commits) {
                const msg = c.commit?.message || "";
                let m;
                while ((m = issueRegex.exec(msg)) !== null) {
                  issueNumbers.add(parseInt(m[1], 10));
                }
              }

            } else if (eventName === "push") {
              if (context.ref !== "refs/heads/test") {
                core.info(`Push is not to test (${context.ref}), skipping.`);
                return;
              }

              const commits = context.payload.commits || [];
              for (const c of commits) {
                const msg = c.message || "";
                let m;
                while ((m = issueRegex.exec(msg)) !== null) {
                  issueNumbers.add(parseInt(m[1], 10));
                }
              }
            } else {
              core.info(`Unsupported event: ${eventName}, skipping.`);
              return;
            }

            if (!issueNumbers.size) {
              core.info("No #<issue> references found.");
              return;
            }

            core.info(`Found issue numbers: ${[...issueNumbers].join(", ")}`);

            async function issueNodeId(num){
              const q = await github.graphql(`query($o:String!,$r:String!,$n:Int!){
                repository(owner:$o,name:$r){
                  issue(number:$n){ id }
                }
              }`, { o: owner, r: repo, n: num }).catch(()=>null);
              return q?.repository?.issue?.id || null;
            }

            async function addItem(contentId){
              const a = await github.graphql(`mutation($p:ID!,$c:ID!){
                addProjectV2ItemById(input:{projectId:$p,contentId:$c}){
                  item{ id }
                }
              }`, { p: projectId, c: contentId }).catch(()=>null);
              return a?.addProjectV2ItemById?.item?.id || null;
            }

            async function currentStatus(itemId){
              const q = await github.graphql(`query($id:ID!){
                node(id:$id){
                  ... on ProjectV2Item {
                    fieldValues(first:50){
                      nodes{
                        ... on ProjectV2ItemFieldSingleSelectValue {
                          name
                          field { ... on ProjectV2SingleSelectField { name id } }
                        }
                      }
                    }
                  }
                }
              }`, { id: itemId });
              const v = q?.node?.fieldValues?.nodes || [];
              return v.find(x => x.field?.name === "Status")?.name || null;
            }

            async function setStatus(itemId, optionId){
              if (!optionId) {
                core.warning("No option id for desired status, skipping.");
                return;
              }
              await github.graphql(`mutation($p:ID!,$i:ID!,$f:ID!,$o:String!){
                updateProjectV2ItemFieldValue(
                  input:{projectId:$p,itemId:$i,fieldId:$f,value:{singleSelectOptionId:$o}}
                ){
                  clientMutationId
                }
              }`, { p: projectId, i: itemId, f: statusFieldId, o: optionId });
            }

            for (const n of issueNumbers) {
              core.info(`Processing issue #${n}`);
              const issueId = await issueNodeId(n);
              if (!issueId) {
                core.warning(`#${n}: issue not found, skipping.`);
                continue;
              }

              const itemId = await addItem(issueId);
              if (!itemId) {
                core.warning(`#${n}: could not ensure project item, skipping.`);
                continue;
              }

              const cur = await currentStatus(itemId);
              core.info(`#${n} current project Status: ${cur ?? "none"}`);

              if (cur === "Testing" || cur === "To Fix" || cur === "Done") {
                core.info(`#${n} already ${cur}, skipping.`);
                continue;
              }

              let targetId;
              if (cur === "To Test") {
                core.info(`#${n}: To Test → Testing`);
                targetId = testingId;
              } else {
                core.info(`#${n}: current status '${cur}' → Invalid`);
                targetId = invalidId;
              }

              await setStatus(itemId, targetId);
              core.info(`#${n} project Status updated.`);
            }
